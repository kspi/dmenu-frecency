#!/usr/bin/env python
"""Dmenu launcher with history sorted by frecency.

Usage:
    dmenu-frecency [--read-apps]

Options:
    --read-apps         rereads all .desktop files.
"""

from docopt import docopt
import os
import sys
import xdg.BaseDirectory
from xdg.DesktopEntry import DesktopEntry
from subprocess import Popen, PIPE
from datetime import datetime
from collections import defaultdict
import pickle
import re
import gzip
import json


CONFIG_DIR = xdg.BaseDirectory.save_config_path('dmenu-frecency')


# Python 2 compatibility
try:
    FileNotFoundError
except NameError:
    FileNotFoundError = IOError


def newer_than(a, b):
    return os.path.getmtime(a) > os.path.getmtime(b)


class BadDesktopFile(Exception):
    pass


class NoDisplayApplication(Exception):
    pass


class Application:
    def __init__(self, name, command, mtime=None, path=None, is_desktop=False):
        self.name = name
        self.command = command
        self.path = path
        self.is_desktop = is_desktop
        self.show_command = False
        if mtime is None:
            self.mtime = datetime.now()
        else:
            self.mtime = mtime

    def run(self):
        if os.fork() == 0:
            if self.path:
                os.chdir(self.path)
            os.execvp('sh', ['sh', '-c', 'exec ' + self.command])

    def __lt__(self, other):
        return self.mtime < other.mtime

    def __eq__(self, other):
        return self.name == other.name

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return "<Application: {} ({})>".format(self.name, self.command)

STATE_VERSION = 3

class LauncherState:
    EXEC_CODES_RE = re.compile(r'\s*%[fFuU]')
    STATE_FILENAME = os.path.join(CONFIG_DIR, 'state')

    def __init__(self):
        self.version = STATE_VERSION
        self.find_apps()
        self.apps_generated_at = datetime.now()
        self.last_visits = 10
        self.visits = defaultdict(list)
        self.visit_count = defaultdict(int)
        self.frecency_cache = {}

    def apps_by_frecency(self):
        for app, frec in sorted(self.frecency_cache.items(), key=lambda x: (-x[1], x[0])):
            yield app
        for app in self.sorted_apps:
            if app not in self.frecency_cache:
                yield app

    def add_visit(self, app):
        if not app.is_desktop and app.command in self.command_apps:
            app = self.command_apps[app.command]
            app.show_command = True
        if app.is_desktop:
            self.sorted_apps.remove(app)
        vs = self.visits[app]
        now = datetime.now()
        vs.append(now)
        self.visit_count[app] += 1
        self.visits[app] = vs[-self.last_visits:]
    
    def update_frecencies(self):
        for app in self.visits.keys():
            self.frecency_cache[app] = self.frecency(app)

    def frecency(self, app):
        points = 0
        for v in self.visits[app]:
            days_ago = (datetime.now() - v).days
            if days_ago < 4:
                points += 100
            elif days_ago < 14:
                points += 70
            elif days_ago < 31:
                points += 50
            elif days_ago < 90:
                points += 30
            else:
                points += 10

        return int(self.visit_count[app] * points / len(self.visits[app]))

    @classmethod
    def load(cls):
        try:
            with gzip.open(cls.STATE_FILENAME, 'rb') as f:
                obj = pickle.load(f)
            version = getattr(obj, 'version', 0)
            if version < STATE_VERSION:
                new_obj = cls()
                if version <= 1:
                    for app, vs in obj.visits.items():
                        vc = obj.visit_count[app]
                        app.is_desktop = True
                        new_obj.visit_count[app] = vc
                        new_obj.visits[app] = vs
                new_obj.find_apps()
                new_obj.clean_cache()
                new_obj.update_frecencies()
                return new_obj
            else:
                return obj
        except FileNotFoundError:
            return cls()

    def save(self):
        with gzip.open(self.STATE_FILENAME, 'wb', 3) as f:
            pickle.dump(self, f)

    def find_apps(self):
        self.apps = {}
        self.command_apps = {}
        for applications_directory in xdg.BaseDirectory.load_data_paths("applications"):
            if os.path.exists(applications_directory):
                for dirpath, dirnames, filenames in os.walk(applications_directory):
                    for f in filenames:
                        if f.endswith('.desktop'):
                            full_filename = os.path.join(dirpath, f)
                            self.add_desktop(full_filename)
        self.sorted_apps = sorted(self.apps.values(), reverse=True)

    def add_desktop(self, filename):
        try:
            d = DesktopEntry(filename)
            if d.getHidden() or d.getNoDisplay() or d.getTerminal() or d.getType() != 'Application':
                return
            name = d.getName()
            app = Application(
                    name=name,
                    command=self.EXEC_CODES_RE.sub('', d.getExec()),
                    mtime=datetime.fromtimestamp(os.path.getmtime(filename)),
                    is_desktop=True)
            if d.getPath():
                app.path = d.getPath()
            if app.command not in self.command_apps:
                self.apps[name] = app
                self.command_apps[app.command] = app
        except (xdg.Exceptions.ParsingError,
                xdg.Exceptions.DuplicateGroupError,
                xdg.Exceptions.DuplicateKeyError):
            pass

    def clean_cache(self):
        for app in list(self.frecency_cache.keys()):
            if app.is_desktop and app.name not in self.apps:
                del self.frecency_cache[app]

class DmenuFrecency:
    CONFIG_FILENAME = os.path.join(CONFIG_DIR, 'config.json')
    DEFAULT_CONFIG = {
        'dmenu': 'dmenu',
        'dmenu-args': ['-i'],
        'cache-days': 1,
        'frecency-visits': 10,
    }
    NAME_WITH_COMMAND = re.compile(r"(.+) \([^()]+\)")

    def __init__(self, arguments):
        self.read_apps = arguments['--read-apps']

        self.state = LauncherState.load()
        assert self.state, "Failed to load state."
        if self.read_apps:
            self.state.find_apps()
            self.state.clean_cache()

        self.load_config()
        self.state.last_visits = self.config['frecency-visits']

    def load_config(self):
        try:
            with open(self.CONFIG_FILENAME, 'r') as f:
                self.config = json.load(f)
        except FileNotFoundError:
            self.config = self.DEFAULT_CONFIG
            with open(self.CONFIG_FILENAME, 'w') as f:
                json.dump(self.config, f, sort_keys=True, indent=4)

    def main(self):
        dmenu = Popen([self.config['dmenu']] + self.config['dmenu-args'], stdin=PIPE, stdout=PIPE)
        for app in self.state.apps_by_frecency():
            dmenu.stdin.write(app.name.encode('utf-8'))
            if app.show_command:
                dmenu.stdin.write(" ({})".format(app.command).encode('utf-8'))
            dmenu.stdin.write(b'\n')
        stdout, stderr = dmenu.communicate()
        result = stdout.decode('utf-8').strip()

        if not result:
            return

        if result in self.state.apps:
            app = self.state.apps[result]
        else:
            m = self.NAME_WITH_COMMAND.match(result)
            if m and m.group(1) in self.state.apps:
                app = self.state.apps[m.group(1)]
            else:
                app = Application(
                        name=result,
                        command=result)

        app.run()

        self.state.add_visit(app)
        self.state.update_frecencies()

        if (datetime.now() - self.state.apps_generated_at).days >= self.config['cache-days']:
            self.state.find_apps()
            self.state.clean_cache()
        self.state.save()


if __name__ == '__main__':
    arguments = docopt(__doc__, version="0.1")
    DmenuFrecency(arguments).main()
